# coding: utf-8

"""
    Coinbase Developer Platform APIs

    The Coinbase Developer Platform APIs - leading the world's transition onchain.

    The version of the OpenAPI document: 2.0.0
    Contact: cdp@coinbase.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated
from cdp.openapi_client.models.webhook_subscription_list_response import WebhookSubscriptionListResponse
from cdp.openapi_client.models.webhook_subscription_request import WebhookSubscriptionRequest
from cdp.openapi_client.models.webhook_subscription_response import WebhookSubscriptionResponse
from cdp.openapi_client.models.webhook_subscription_update_request import WebhookSubscriptionUpdateRequest

from cdp.openapi_client.api_client import ApiClient, RequestSerialized
from cdp.openapi_client.api_response import ApiResponse
from cdp.openapi_client.rest import RESTResponseType


class WebhooksApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def create_webhook_subscription(
        self,
        webhook_subscription_request: Optional[WebhookSubscriptionRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookSubscriptionResponse:
        """Create webhook subscription

        Subscribe to real-time events across CDP products using flexible filtering.  ### Event Types  **Onchain Events** - Monitor Base mainnet with microsecond precision: - `onchain.activity.detected` - Smart contract events, transfers, swaps, NFT activity - **Requires** `labels` for filtering (e.g., `contract_address`, `event_name`)  **Onramp/Offramp Events** - Transaction lifecycle notifications: - `onramp.transaction.created`, `onramp.transaction.updated` - `onramp.transaction.success`, `onramp.transaction.failed` - `offramp.transaction.created`, `offramp.transaction.updated` - `offramp.transaction.success`, `offramp.transaction.failed` - **No labels required** - maximum simplicity for transaction monitoring  **Wallet Events** - Wallet activity notifications: - `wallet.activity.detected`  ### Webhook Signature Verification All webhooks include cryptographic signatures for security. The signature secret is returned in `metadata.secret` when creating a subscription.  **Note:** Webhooks are in beta and this interface is subject to change.  See the [verification guide](https://docs.cdp.coinbase.com/onramp-&-offramp/webhooks#webhook-signature-verification) for implementation details.  ### Onchain Label Filtering  For `onchain.activity.detected` events, use `labels` for precise filtering with AND logic (max 20 labels per webhook).  **Allowed labels** (all in snake_case format): - `network` (required) - Blockchain network - `contract_address` - Smart contract address - `event_name` - Event name (e.g., \"Transfer\", \"Burn\") - `event_signature` - Event signature hash - `transaction_from` - Transaction sender address - `transaction_to` - Transaction recipient address - `params.*` - Any event parameter (e.g., `params.from`, `params.to`, `params.sender`, `params.tokenId`)  **Examples**: - **Liquidity Pool Monitor**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0xcd1f9777571493aeacb7eae45cd30a226d3e612d\", \"event_name\": \"Burn\"}` - **Price Oracle Tracker**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0xbac4a9428ea707c51f171ed9890c3c2fa810305d\", \"event_name\": \"PriceUpdated\"}` - **DeFi Protocol Activity**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0x45c6e6a47a711b14d8357d5243f46704904578e3\", \"event_name\": \"Deposit\"}` 

        :param webhook_subscription_request: (required)
        :type webhook_subscription_request: WebhookSubscriptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_webhook_subscription_serialize(
            webhook_subscription_request=webhook_subscription_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WebhookSubscriptionResponse",
            '400': "Error",
            '401': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def create_webhook_subscription_with_http_info(
        self,
        webhook_subscription_request: Optional[WebhookSubscriptionRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookSubscriptionResponse]:
        """Create webhook subscription

        Subscribe to real-time events across CDP products using flexible filtering.  ### Event Types  **Onchain Events** - Monitor Base mainnet with microsecond precision: - `onchain.activity.detected` - Smart contract events, transfers, swaps, NFT activity - **Requires** `labels` for filtering (e.g., `contract_address`, `event_name`)  **Onramp/Offramp Events** - Transaction lifecycle notifications: - `onramp.transaction.created`, `onramp.transaction.updated` - `onramp.transaction.success`, `onramp.transaction.failed` - `offramp.transaction.created`, `offramp.transaction.updated` - `offramp.transaction.success`, `offramp.transaction.failed` - **No labels required** - maximum simplicity for transaction monitoring  **Wallet Events** - Wallet activity notifications: - `wallet.activity.detected`  ### Webhook Signature Verification All webhooks include cryptographic signatures for security. The signature secret is returned in `metadata.secret` when creating a subscription.  **Note:** Webhooks are in beta and this interface is subject to change.  See the [verification guide](https://docs.cdp.coinbase.com/onramp-&-offramp/webhooks#webhook-signature-verification) for implementation details.  ### Onchain Label Filtering  For `onchain.activity.detected` events, use `labels` for precise filtering with AND logic (max 20 labels per webhook).  **Allowed labels** (all in snake_case format): - `network` (required) - Blockchain network - `contract_address` - Smart contract address - `event_name` - Event name (e.g., \"Transfer\", \"Burn\") - `event_signature` - Event signature hash - `transaction_from` - Transaction sender address - `transaction_to` - Transaction recipient address - `params.*` - Any event parameter (e.g., `params.from`, `params.to`, `params.sender`, `params.tokenId`)  **Examples**: - **Liquidity Pool Monitor**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0xcd1f9777571493aeacb7eae45cd30a226d3e612d\", \"event_name\": \"Burn\"}` - **Price Oracle Tracker**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0xbac4a9428ea707c51f171ed9890c3c2fa810305d\", \"event_name\": \"PriceUpdated\"}` - **DeFi Protocol Activity**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0x45c6e6a47a711b14d8357d5243f46704904578e3\", \"event_name\": \"Deposit\"}` 

        :param webhook_subscription_request: (required)
        :type webhook_subscription_request: WebhookSubscriptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_webhook_subscription_serialize(
            webhook_subscription_request=webhook_subscription_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WebhookSubscriptionResponse",
            '400': "Error",
            '401': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def create_webhook_subscription_without_preload_content(
        self,
        webhook_subscription_request: Optional[WebhookSubscriptionRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create webhook subscription

        Subscribe to real-time events across CDP products using flexible filtering.  ### Event Types  **Onchain Events** - Monitor Base mainnet with microsecond precision: - `onchain.activity.detected` - Smart contract events, transfers, swaps, NFT activity - **Requires** `labels` for filtering (e.g., `contract_address`, `event_name`)  **Onramp/Offramp Events** - Transaction lifecycle notifications: - `onramp.transaction.created`, `onramp.transaction.updated` - `onramp.transaction.success`, `onramp.transaction.failed` - `offramp.transaction.created`, `offramp.transaction.updated` - `offramp.transaction.success`, `offramp.transaction.failed` - **No labels required** - maximum simplicity for transaction monitoring  **Wallet Events** - Wallet activity notifications: - `wallet.activity.detected`  ### Webhook Signature Verification All webhooks include cryptographic signatures for security. The signature secret is returned in `metadata.secret` when creating a subscription.  **Note:** Webhooks are in beta and this interface is subject to change.  See the [verification guide](https://docs.cdp.coinbase.com/onramp-&-offramp/webhooks#webhook-signature-verification) for implementation details.  ### Onchain Label Filtering  For `onchain.activity.detected` events, use `labels` for precise filtering with AND logic (max 20 labels per webhook).  **Allowed labels** (all in snake_case format): - `network` (required) - Blockchain network - `contract_address` - Smart contract address - `event_name` - Event name (e.g., \"Transfer\", \"Burn\") - `event_signature` - Event signature hash - `transaction_from` - Transaction sender address - `transaction_to` - Transaction recipient address - `params.*` - Any event parameter (e.g., `params.from`, `params.to`, `params.sender`, `params.tokenId`)  **Examples**: - **Liquidity Pool Monitor**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0xcd1f9777571493aeacb7eae45cd30a226d3e612d\", \"event_name\": \"Burn\"}` - **Price Oracle Tracker**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0xbac4a9428ea707c51f171ed9890c3c2fa810305d\", \"event_name\": \"PriceUpdated\"}` - **DeFi Protocol Activity**: `{\"network\": \"base-mainnet\", \"contract_address\": \"0x45c6e6a47a711b14d8357d5243f46704904578e3\", \"event_name\": \"Deposit\"}` 

        :param webhook_subscription_request: (required)
        :type webhook_subscription_request: WebhookSubscriptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_webhook_subscription_serialize(
            webhook_subscription_request=webhook_subscription_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WebhookSubscriptionResponse",
            '400': "Error",
            '401': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_webhook_subscription_serialize(
        self,
        webhook_subscription_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if webhook_subscription_request is not None:
            _body_params = webhook_subscription_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/data/webhooks/subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def delete_webhook_subscription(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete webhook subscription

        Permanently delete a webhook subscription and stop all event deliveries. This action cannot be undone.  ### Important Notes - All webhook deliveries will cease immediately - Subscription cannot be recovered after deletion - Consider disabling instead of deleting for temporary pauses 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_serialize(
            subscription_id=subscription_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def delete_webhook_subscription_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete webhook subscription

        Permanently delete a webhook subscription and stop all event deliveries. This action cannot be undone.  ### Important Notes - All webhook deliveries will cease immediately - Subscription cannot be recovered after deletion - Consider disabling instead of deleting for temporary pauses 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_serialize(
            subscription_id=subscription_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def delete_webhook_subscription_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete webhook subscription

        Permanently delete a webhook subscription and stop all event deliveries. This action cannot be undone.  ### Important Notes - All webhook deliveries will cease immediately - Subscription cannot be recovered after deletion - Consider disabling instead of deleting for temporary pauses 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_webhook_subscription_serialize(
            subscription_id=subscription_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_webhook_subscription_serialize(
        self,
        subscription_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscriptionId'] = subscription_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/data/webhooks/subscriptions/{subscriptionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_webhook_subscription(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookSubscriptionResponse:
        """Get webhook subscription details

        Retrieve detailed information about a specific webhook subscription including configuration, status, creation timestamp, and webhook signature secret.  ### Response Includes - Subscription configuration and filters - Target URL and custom headers - Webhook signature secret for verification - Creation timestamp and status 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_webhook_subscription_serialize(
            subscription_id=subscription_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionResponse",
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_webhook_subscription_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookSubscriptionResponse]:
        """Get webhook subscription details

        Retrieve detailed information about a specific webhook subscription including configuration, status, creation timestamp, and webhook signature secret.  ### Response Includes - Subscription configuration and filters - Target URL and custom headers - Webhook signature secret for verification - Creation timestamp and status 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_webhook_subscription_serialize(
            subscription_id=subscription_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionResponse",
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_webhook_subscription_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get webhook subscription details

        Retrieve detailed information about a specific webhook subscription including configuration, status, creation timestamp, and webhook signature secret.  ### Response Includes - Subscription configuration and filters - Target URL and custom headers - Webhook signature secret for verification - Creation timestamp and status 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_webhook_subscription_serialize(
            subscription_id=subscription_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionResponse",
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_webhook_subscription_serialize(
        self,
        subscription_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscriptionId'] = subscription_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/data/webhooks/subscriptions/{subscriptionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def list_webhook_subscriptions(
        self,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of subscriptions to return per page.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The token for the next page of subscriptions, if any.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookSubscriptionListResponse:
        """List webhook subscriptions

        Retrieve a paginated list of webhook subscriptions for the authenticated project. Returns subscriptions for all CDP product events (onchain, onramp/offramp, wallet, etc.) in descending order by creation time.  ### Use Cases - Monitor all active webhook subscriptions across CDP products - Audit webhook configurations - Manage subscription lifecycle 

        :param page_size: The number of subscriptions to return per page.
        :type page_size: int
        :param page_token: The token for the next page of subscriptions, if any.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_webhook_subscriptions_serialize(
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionListResponse",
            '400': "Error",
            '401': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def list_webhook_subscriptions_with_http_info(
        self,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of subscriptions to return per page.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The token for the next page of subscriptions, if any.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookSubscriptionListResponse]:
        """List webhook subscriptions

        Retrieve a paginated list of webhook subscriptions for the authenticated project. Returns subscriptions for all CDP product events (onchain, onramp/offramp, wallet, etc.) in descending order by creation time.  ### Use Cases - Monitor all active webhook subscriptions across CDP products - Audit webhook configurations - Manage subscription lifecycle 

        :param page_size: The number of subscriptions to return per page.
        :type page_size: int
        :param page_token: The token for the next page of subscriptions, if any.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_webhook_subscriptions_serialize(
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionListResponse",
            '400': "Error",
            '401': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def list_webhook_subscriptions_without_preload_content(
        self,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of subscriptions to return per page.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The token for the next page of subscriptions, if any.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List webhook subscriptions

        Retrieve a paginated list of webhook subscriptions for the authenticated project. Returns subscriptions for all CDP product events (onchain, onramp/offramp, wallet, etc.) in descending order by creation time.  ### Use Cases - Monitor all active webhook subscriptions across CDP products - Audit webhook configurations - Manage subscription lifecycle 

        :param page_size: The number of subscriptions to return per page.
        :type page_size: int
        :param page_token: The token for the next page of subscriptions, if any.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_webhook_subscriptions_serialize(
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionListResponse",
            '400': "Error",
            '401': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_webhook_subscriptions_serialize(
        self,
        page_size,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/data/webhooks/subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def update_webhook_subscription(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        webhook_subscription_update_request: Optional[WebhookSubscriptionUpdateRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WebhookSubscriptionResponse:
        """Update webhook subscription

        Update an existing webhook subscription's configuration including event types, target URL, filtering criteria, and enabled status. All required fields must be provided, even if they are not being changed.  ### Common Updates - Change target URL or headers - Add/remove event type filters - Update multi-label filtering criteria - Enable/disable subscription 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param webhook_subscription_update_request: (required)
        :type webhook_subscription_update_request: WebhookSubscriptionUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_serialize(
            subscription_id=subscription_id,
            webhook_subscription_update_request=webhook_subscription_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionResponse",
            '400': "Error",
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def update_webhook_subscription_with_http_info(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        webhook_subscription_update_request: Optional[WebhookSubscriptionUpdateRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WebhookSubscriptionResponse]:
        """Update webhook subscription

        Update an existing webhook subscription's configuration including event types, target URL, filtering criteria, and enabled status. All required fields must be provided, even if they are not being changed.  ### Common Updates - Change target URL or headers - Add/remove event type filters - Update multi-label filtering criteria - Enable/disable subscription 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param webhook_subscription_update_request: (required)
        :type webhook_subscription_update_request: WebhookSubscriptionUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_serialize(
            subscription_id=subscription_id,
            webhook_subscription_update_request=webhook_subscription_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionResponse",
            '400': "Error",
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def update_webhook_subscription_without_preload_content(
        self,
        subscription_id: Annotated[StrictStr, Field(description="Unique identifier for the webhook subscription.")],
        webhook_subscription_update_request: Optional[WebhookSubscriptionUpdateRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update webhook subscription

        Update an existing webhook subscription's configuration including event types, target URL, filtering criteria, and enabled status. All required fields must be provided, even if they are not being changed.  ### Common Updates - Change target URL or headers - Add/remove event type filters - Update multi-label filtering criteria - Enable/disable subscription 

        :param subscription_id: Unique identifier for the webhook subscription. (required)
        :type subscription_id: str
        :param webhook_subscription_update_request: (required)
        :type webhook_subscription_update_request: WebhookSubscriptionUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_webhook_subscription_serialize(
            subscription_id=subscription_id,
            webhook_subscription_update_request=webhook_subscription_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WebhookSubscriptionResponse",
            '400': "Error",
            '401': "Error",
            '404': "Error",
            '429': "Error",
            '500': "Error",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_webhook_subscription_serialize(
        self,
        subscription_id,
        webhook_subscription_update_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription_id is not None:
            _path_params['subscriptionId'] = subscription_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if webhook_subscription_update_request is not None:
            _body_params = webhook_subscription_update_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v2/data/webhooks/subscriptions/{subscriptionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


